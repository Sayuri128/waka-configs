import waka_json;
import waka_http;
import waka_collections;
import waka_models;

func getCover(coverArtUid, mangaId) {

    cover = "";

    coverResult = httpGet({
        url: "https://api.mangadex.org/cover/coverArtId",
        params: {},
        paths: {
            coverArtId: coverArtUid
        }
    });

    decodedCover = jsonDecode(coverResult["body"]);

    coverStatusResult = decodedCover["result"];

    if(coverStatusResult == "ok") {
        fileName = decodedCover["data"].attributes.fileName;
        cover = "https://mangadex.org/covers/" + mangaId + "/" + fileName;
    }

    return cover;
}

func getCoverId(data) {
    coverArtId = "";
    for(i = 0; i < data.length; i = i + 1) {
        if(data[i].type == "cover_art") {
            coverArtId = data[i]["id"];
        }
    }
    return coverArtId;
}

func handleMangaItem(manga) {
    uid = manga["id"];
    title = manga["attributes"]["title"].values.first;

    cover = getCover({
        coverArtUid: getCoverId({
            data: manga["relationships"]
        }),
        mangaId: uid
    });

    return buildGallery({
        uid: uid,
        title: title,
        cover: cover
    });
}

func getGallery(page, query, filters) {

    limit = 2;

    params = {
        limit: limit,
        offset: limit * page
    };

    for(i = 0; i < filters.length; i = i + 1) {
        filterData = filters[i];
        filter = filterData["filter"];
        if(filter["type"] == "ONE_OF_MULTIPLE") {
            params[filter.param] = filterData["selected"];
        } else if(filter["type"] == "ONE_OF_ANY") {
            params[filter.param] = filterData["selected"];
        } else if(filter["type"] == "MULTIPLE_OF_ANY") {
            params[filter.param] = filterData["selected"];
        } else if(filter["type"] == "MULTIPLE_OF_MULTIPLE") {
            selected = [];

            for(j = 0; j < filterData["selected"].length; j = j + 1) {
                addToList(selected, filterData["selected"][j][0]);
            }

            params[filter.param] = selected;
        } else if(filter["type"] == "SWITCHER") {
            params[filter.param] = filterData["on"];
        }
    }

    print(params);


    if(query != "") {
        params["title"] = query;
    }

    result = (httpGet({
        url: "https://api.mangadex.org/manga",
        params: params,
        paths: {}
    }));

    decoded = jsonDecode(result["body"]);
    data = decoded["data"];

    mangas = [];

    for(i = 0; i < data.length; i = i + 1) {
        addToList(mangas, handleMangaItem({
            manga: data[i]
        }));
    }

    return mangas;
}

func getChaptersData(uid, offset) {
    return httpGet({
        url: "https://api.mangadex.org/manga/mangaId/feed",
        params: {
            limit: 100,
            offset: offset,
            translatedLanguage: ["en"],
            order: {
                volume: "asc",
                chapter: "asc"
            }
        },
        paths: {
            mangaId: uid
        }
    });
}

func handleChapterItem(chapter) {
    uid = chapter["id"];

    attr = chapter["attributes"];

    prefix = "";

    if(attr["volume"] != null) {
        prefix = prefix + "Volume " + attr["volume"];
    }
    if(attr["chapter"] != null) {
       prefix = prefix + " Chapter " + attr["chapter"];
    }

    title = chapter["attributes"]["title"];
    if(title == null) {
        title = prefix;
    } else {
        title = prefix + " | " + title;
    }

    timestamp = chapter["attributes"]["publishAt"];


    return buildChapter({
        uid: uid,
        title: title,
        timestamp: timestamp
    });
}

func getChapters(uid)  {

    firstChapters = getChaptersData({
        offset: 0,
        uid: uid
    });
    result = jsonDecode(firstChapters["body"]);
    data = result["data"];

    chapters = [];

    for(i = 0; chapters.length < result["total"]; i = i + 1) {
        if(i == data.length) {
            firstChapters = getChaptersData({
                offset: 0,
                uid: uid
            });
            result = jsonDecode(firstChapters["body"]);
            data = result["data"];
            i = 0;
        }
        addToList(chapters, handleChapterItem({
            chapter: data[i]
        }));
    }

    return chapters;
}

func getPages(uid) {

    result = httpGet({
        url: "https://api.mangadex.org/at-home/server/chapterUid",
        params: {},
        paths: {
            chapterUid: uid
        }
    });

    body = jsonDecode(result["body"]);

    if(body["result"] != "ok") {
       return buildPages({
           uid: uid,
           value: []
       });
    }

    data = body["chapter"]["data"];

    value = [];

    for(i = 0; i < data.length; i = i + 1) {
        addToList(value, "https://uploads.mangadex.org/data/" + body["chapter"]["hash"] + "/" + data[i]);
    }

    return buildPages({
        uid: uid,
        value: value
    });
}

func handleConcreteView(data) {

    originalTitle = data["attributes"]["title"].values.first;
    prettyTitle = originalTitle;

    title = buildTitle({
        original: originalTitle,
        pretty: ""
    });

    cover = getCover({
        coverArtUid: getCoverId({
            data: data["relationships"]
        }),
        mangaId: data["id"]
    });

    rawTags = data["attributes"]["tags"];

    tags = [];

    for(i = 0; i < rawTags.length; i = i + 1) {
        addToList(tags, rawTags[i]["attributes"]["name"].values.first);
    }

    chapters = [];

    return buildConcrete({
        title: title,
        cover: cover,
        tags: tags,
        chapters: getChapters({
            uid: data["id"]
        })
    });
}

func getConcrete(uid) {

    result = httpGet({
        url: "https://api.mangadex.org/manga/uid",
        params: {},
        paths: {
            uid: uid
        }
    });

    body = jsonDecode(result["body"]);

    concrete = handleConcreteView({
        data: body["data"]
    });

    return concrete;
}

func getConfigInfo() {

    availableYears = [];

    for(i = 1950; i <= 2022; i = i + 1) {
        addToList(availableYears, i);
    }

    return buildConfigInfo({
        name: "MangaDex",
        logoUrl: "https://mangadex.org/_nuxt/ddb5721c5458b5edc9d6782a5f107119.svg",
        nsfw: false,
        language: "Eng",
        version: 1,
        filters: [
            buildMultipleOfAny({
                paramName: "Authors",
                param: "authors"
            }),
            buildMultipleOfAny({
                paramName: "Artists",
                param: "artists"
            }),
            buildOneOfMultiple({
                paramName: "Year of release",
                param: "year",
                values: availableYears
            }),
            buildMultipleOfAny({
                paramName: "Tags",
                param: "includedTags"
            }),
            buildSwitcher({
                paramName: "Tags mode",
                param: "includedTagsMode",
                onValue: "AND",
                offValue: "OR"
            }),
            buildMultipleOfAny({
                paramName: "Exclude tags",
                param: "excludedTags"
            }),
            buildSwitcher({
                paramName: "Exclude tags mode",
                param: "excludedTagsMode",
                onValue: "AND",
                offValue: "OR"
            }),
            buildMultipleOfMultiple({
                paramName: "Status",
                param: "status",
                values: [
                    ["ongoing", "Ongoing"],
                    ["completed", "Completed"],
                    ["hiatus", "Hiatus"],
                    ["cancelled", "Cancelled"],
                ]
            }),
            buildMultipleOfMultiple({
                paramName: "Base genre",
                param: "publicationDemographic",
                values: [
                    ["shounen", "Shounen"],
                    ["shoujo", "Shoujo"],
                    ["josei", "Josei"],
                    ["seinen", "Seinen"],
                    ["none", "None"],
                ]
            }),
            buildMultipleOfMultiple({
                paramName: "Content rating",
                param: "contentRaing",
                values: [
                    ["safe", "Safe"],
                    ["suggestive", "Suggestive"],
                    ["erotica", "Erotica"]
                ]
            }),
            buildOneOfAny({
                paramName: "Test",
                param: "test"
            })
        ]
    });
}


func main() {
    // gallery = getGallery({
    //     page: 2,
    //     query: ""
    // });

    // print(gallery);

//    concrete = getConcrete({
//     uid: gallery[0]["uid"]
//    });

    // concrete = getChapters({
    //     uid: "4076579f-0d95-4f30-9c5f-7f230fa205d9"
    // });
    configInfo = getConfigInfo();

    print(configInfo);

   // print(concrete["value"]);

//    print(gallery);

}
